From bbd9964041463eafea84d7fe3c6dc47c6b3ed6c7 Mon Sep 17 00:00:00 2001
From: Fabrice CARUSO <fabrice.caruso@free.fr>
Date: Mon, 21 Dec 2020 10:03:41 +0100
Subject: [PATCH] CarouselGameListView : initial version

---
 es-app/CMakeLists.txt                         |   8 +-
 es-app/src/components/CarouselComponent.cpp   | 632 ++++++++++++++++++
 es-app/src/components/CarouselComponent.h     | 101 +++
 es-app/src/guis/GuiMenu.cpp                   |   4 +-
 es-app/src/views/ViewController.cpp           |   7 +
 es-app/src/views/ViewController.h             |   3 +-
 .../views/gamelist/CarouselGameListView.cpp   | 289 ++++++++
 .../src/views/gamelist/CarouselGameListView.h |  49 ++
 es-core/src/ThemeData.cpp                     |  22 +-
 9 files changed, 1108 insertions(+), 7 deletions(-)
 create mode 100644 es-app/src/components/CarouselComponent.cpp
 create mode 100644 es-app/src/components/CarouselComponent.h
 create mode 100644 es-app/src/views/gamelist/CarouselGameListView.cpp
 create mode 100644 es-app/src/views/gamelist/CarouselGameListView.h

diff --git a/es-app/CMakeLists.txt b/es-app/CMakeLists.txt
index 217ed340..14893b9a 100644
--- a/es-app/CMakeLists.txt
+++ b/es-app/CMakeLists.txt
@@ -29,6 +29,7 @@ set(ES_HEADERS
     ${CMAKE_CURRENT_SOURCE_DIR}/src/components/RatingComponent.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/components/ScraperSearchComponent.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/components/TextListComponent.h
+	${CMAKE_CURRENT_SOURCE_DIR}/src/components/CarouselComponent.h
 
     # Guis
     ${CMAKE_CURRENT_SOURCE_DIR}/src/guis/GuiFastSelect.h
@@ -74,12 +75,13 @@ set(ES_HEADERS
 
     # Views
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/BasicGameListView.h
+	${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/CarouselGameListView.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/DetailedGameListView.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/IGameListView.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/ISimpleGameListView.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/GridGameListView.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/VideoGameListView.h
-	${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/DetailedContainer.h
+	${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/DetailedContainer.h	
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/SystemView.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/ViewController.h
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/UIModeController.h
@@ -120,6 +122,7 @@ set(ES_SOURCES
     ${CMAKE_CURRENT_SOURCE_DIR}/src/components/AsyncReqComponent.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/components/RatingComponent.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/components/ScraperSearchComponent.cpp
+	${CMAKE_CURRENT_SOURCE_DIR}/src/components/CarouselComponent.cpp
 
     # Guis
     ${CMAKE_CURRENT_SOURCE_DIR}/src/guis/GuiFastSelect.cpp
@@ -161,12 +164,13 @@ set(ES_SOURCES
 
     # Views
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/BasicGameListView.cpp
+	${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/CarouselGameListView.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/DetailedGameListView.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/IGameListView.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/ISimpleGameListView.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/GridGameListView.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/VideoGameListView.cpp
-	${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/DetailedContainer.cpp
+	${CMAKE_CURRENT_SOURCE_DIR}/src/views/gamelist/DetailedContainer.cpp	
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/SystemView.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/ViewController.cpp
     ${CMAKE_CURRENT_SOURCE_DIR}/src/views/UIModeController.cpp
diff --git a/es-app/src/components/CarouselComponent.cpp b/es-app/src/components/CarouselComponent.cpp
new file mode 100644
index 00000000..e07ac092
--- /dev/null
+++ b/es-app/src/components/CarouselComponent.cpp
@@ -0,0 +1,632 @@
+#include "CarouselComponent.h"
+#include "FileData.h"
+#include "Settings.h"
+#include "Log.h"
+#include "animations/LambdaAnimation.h"
+#include "Sound.h"
+#include "LocaleES.h"
+
+// buffer values for scrolling velocity (left, stopped, right)
+const int logoBuffersLeft[] = { -5, -2, -1 };
+const int logoBuffersRight[] = { 1, 2, 5 };
+
+CarouselComponent::CarouselComponent(Window* window) :
+	IList<CarouselComponentData, FileData*>(window, LIST_SCROLL_STYLE_SLOW, LIST_ALWAYS_LOOP)
+{
+	mCamOffset = 0;
+	mScreensaverActive = false;
+	mDisable = false;		
+	mLastCursor = 0;
+		
+	setSize((float)Renderer::getScreenWidth(), (float)Renderer::getScreenHeight());
+
+	mType = VERTICAL;
+	mLogoAlignment = ALIGN_CENTER;
+	mLogoScale = 1.2f;
+	mLogoRotation = 7.5;
+	mLogoRotationOrigin.x() = -5;
+	mLogoRotationOrigin.y() = 0.5;
+	mLogoSize.x() = 0.25f * mSize.x();
+	mLogoSize.y() = 0.155f * mSize.y();
+	mLogoPos = Vector2f(-1, -1);
+	mMaxLogoCount = 3;	
+	mScrollSound = "";
+	mDefaultTransition = "";
+}
+
+CarouselComponent::~CarouselComponent()
+{
+	clearEntries();
+}
+
+void CarouselComponent::clearEntries()
+{
+	mEntries.clear();
+}
+
+int CarouselComponent::moveCursorFast(bool forward)
+{
+	int value = mCursor;
+	int count = forward ? 10 : -10;
+	int sz = mEntries.size();
+
+	if (count >= sz)
+		return value;
+
+	value += count;
+	if (value < 0) 
+		value += sz;
+	if (value >= sz) 
+		value -= sz;
+
+	return value;
+}
+
+bool CarouselComponent::input(InputConfig* config, Input input)
+{
+	if(input.value != 0)
+	{	
+		switch (mType)
+		{
+		case VERTICAL:
+		case VERTICAL_WHEEL:
+			if (config->isMappedLike("up", input) || config->isMappedLike("l2", input))
+			{
+				listInput(-1);
+				return true;
+			}
+			if (config->isMappedLike("down", input) || config->isMappedLike("r2", input))
+			{
+				listInput(1);
+				return true;
+			}
+			if (config->isMappedTo("pagedown", input))
+			{
+				int cursor = moveCursorFast(true);
+				listInput(cursor - mCursor);				
+				return true;
+			}
+			if (config->isMappedTo("pageup", input))
+			{
+				int cursor = moveCursorFast(false);
+				listInput(cursor - mCursor);
+				return true;
+			}
+
+			break;
+		case HORIZONTAL:
+		case HORIZONTAL_WHEEL:
+		default:
+			if (config->isMappedLike("left", input) || config->isMappedLike("l2", input))
+			{
+				listInput(-1);
+				return true;
+			}
+			if (config->isMappedLike("right", input) || config->isMappedLike("r2", input))
+			{
+				listInput(1);
+				return true;
+			}
+			if (config->isMappedTo("pagedown", input))
+			{
+				int cursor = moveCursorFast(true);
+				listInput(cursor - mCursor);
+				return true;
+			}
+			if (config->isMappedTo("pageup", input))
+			{
+				int cursor = moveCursorFast(false);
+				listInput(cursor - mCursor);
+				return true;
+			}
+
+			break;
+		}		
+	}
+	else
+	{
+		if(config->isMappedLike("left", input) ||
+			config->isMappedLike("right", input) ||
+			config->isMappedLike("up", input) ||
+			config->isMappedLike("down", input) ||
+			config->isMappedLike("pagedown", input) ||
+			config->isMappedLike("pageup", input) ||
+			config->isMappedLike("l2", input) ||
+			config->isMappedLike("r2", input))
+			listInput(0);
+	}
+
+	return GuiComponent::input(config, input);
+}
+
+void CarouselComponent::update(int deltaTime)
+{		
+	for (int i = 0; i < mEntries.size(); i++)
+	{
+		const std::shared_ptr<GuiComponent> &comp = mEntries.at(i).data.logo;
+		if (comp != nullptr)
+			comp->update(deltaTime);
+	}
+	
+	listUpdate(deltaTime);	
+
+	GuiComponent::update(deltaTime);
+}
+
+void CarouselComponent::onCursorChanged(const CursorState& state)
+{
+	// update help style
+	updateHelpPrompts();
+
+	float startPos = mCamOffset;
+
+	float posMax = (float)mEntries.size();
+	float target = (float)mCursor;
+
+	// what's the shortest way to get to our target?
+	// it's one of these...
+
+	float endPos = target; // directly
+	float dist = abs(endPos - startPos);
+
+	if(abs(target + posMax - startPos) < dist)
+		endPos = target + posMax; // loop around the end (0 -> max)
+	if(abs(target - posMax - startPos) < dist)
+		endPos = target - posMax; // loop around the start (max - 1 -> -1)
+
+	cancelAnimation(1);
+	cancelAnimation(2);
+
+	std::string transition_style = Settings::getInstance()->getString("TransitionStyle");
+	if (transition_style == "auto")
+	{
+		if (mDefaultTransition == "instant" || mDefaultTransition == "fade" || mDefaultTransition == "slide" || mDefaultTransition == "fade & slide")
+			transition_style = mDefaultTransition;
+		else
+			transition_style = "slide";
+	}
+
+	// no need to animate transition, we're not going anywhere (probably mEntries.size() == 1)
+	//if(endPos == mCamOffset)
+		//return;
+
+	if (mLastCursor == mCursor)
+		return;
+
+	if (!mScrollSound.empty())
+		Sound::get(mScrollSound)->play();
+
+	int oldCursor = mLastCursor;
+	mLastCursor = mCursor;
+
+	// TODO
+
+	if (oldCursor >= 0 && oldCursor < mEntries.size())
+	{
+		auto logo = mEntries.at(oldCursor).data.logo;				
+		if (logo)
+		{
+			if (logo->selectStoryboard("deactivate"))
+				logo->startStoryboard();
+			else if (!logo->selectStoryboard())
+				logo->deselectStoryboard();
+		}
+	}
+
+	if (mCursor >= 0 && mCursor < mEntries.size())
+	{
+		auto logo = mEntries.at(mCursor).data.logo;
+		if (logo)
+		{
+			if (logo->selectStoryboard("activate"))
+				logo->startStoryboard();
+			else if (!logo->selectStoryboard())
+				logo->deselectStoryboard();
+		}
+	}
+
+	Animation* anim;
+	bool move_carousel = Settings::getInstance()->getBool("MoveCarousel");
+	if (Settings::getInstance()->getString("PowerSaverMode") == "instant")
+		move_carousel = false;
+
+	if (transition_style == "fade" || transition_style == "fade & slide")
+	{
+		anim = new LambdaAnimation([this, startPos, endPos, posMax, move_carousel, oldCursor, transition_style](float t)
+		{
+			float f = Math::lerp(startPos, endPos, Math::easeOutQuint(t));
+
+			if (f < 0) f += posMax;
+			if (f >= posMax) f -= posMax;
+
+			this->mCamOffset = move_carousel ? f : endPos;
+		}, 500);
+	} 
+	else if (transition_style == "slide") 
+	{
+		anim = new LambdaAnimation([this, startPos, endPos, posMax, move_carousel](float t)
+		{			
+			float f = Math::lerp(startPos, endPos, Math::easeOutQuint(t));
+			if (f < 0) f += posMax;
+			if (f >= posMax) f -= posMax;
+
+			this->mCamOffset = move_carousel ? f : endPos;			
+
+		}, 500);
+	} 
+	else // instant
+	{		
+		anim = new LambdaAnimation([this, startPos, endPos, posMax, move_carousel ](float t)
+		{
+			float f = Math::lerp(startPos, endPos, Math::easeOutQuint(t));
+			if (f < 0) f += posMax; 
+			if (f >= posMax) f -= posMax;
+
+			this->mCamOffset = move_carousel ? f : endPos;			
+
+		}, move_carousel ? 500 : 1);
+	}
+
+	if (mCursorChangedCallback)
+		mCursorChangedCallback(state);
+
+	setAnimation(anim, 0, [this, state]
+	{
+		if (mCursorChangedCallback)
+			mCursorChangedCallback(state);
+	}, false, 0);
+}
+
+void CarouselComponent::render(const Transform4x4f& parentTrans)
+{
+	if (size() == 0 || !mVisible)
+		return;  // nothing to render
+
+	Transform4x4f trans = getTransform() * parentTrans;
+
+	if (!Renderer::isVisibleOnScreen(trans.translation().x(), trans.translation().y(), mSize.x(), mSize.y()))
+		return;
+
+	Renderer::pushClipRect(Vector2i(trans.translation().x(), trans.translation().y()), Vector2i(mSize.x(), mSize.y()));
+	renderCarousel(trans);
+	Renderer::popClipRect();
+}
+
+std::vector<HelpPrompt> CarouselComponent::getHelpPrompts()
+{
+	std::vector<HelpPrompt> prompts;
+
+	if (mType == VERTICAL || mType == VERTICAL_WHEEL)
+		prompts.push_back(HelpPrompt("up/down", _("CHOOSE")));
+	else
+		prompts.push_back(HelpPrompt("left/right", _("CHOOSE")));
+
+	return prompts;
+}
+
+//  Render system carousel
+void CarouselComponent::renderCarousel(const Transform4x4f& trans)
+{
+	Transform4x4f carouselTrans = trans;
+	
+	Renderer::setMatrix(carouselTrans);
+
+	// draw logos
+	Vector2f logoSpacing(0.0, 0.0); // NB: logoSpacing will include the size of the logo itself as well!
+	float xOff = 0.0;
+	float yOff = 0.0;
+
+	switch (mType)
+	{
+		case VERTICAL_WHEEL:
+			yOff = (mSize.y() - mLogoSize.y()) / 2.f - (mCamOffset * logoSpacing[1]);
+			if (mLogoAlignment == ALIGN_LEFT)
+				xOff = mLogoSize.x() / 10.f;
+			else if (mLogoAlignment == ALIGN_RIGHT)
+				xOff = mSize.x() - (mLogoSize.x() * 1.1f);
+			else
+				xOff = (mSize.x() - mLogoSize.x()) / 2.f;
+			break;
+		case VERTICAL:
+			logoSpacing[1] = ((mSize.y() - (mLogoSize.y() * mMaxLogoCount)) / (mMaxLogoCount)) + mLogoSize.y();
+			yOff = (mSize.y() - mLogoSize.y()) / 2.f - (mCamOffset * logoSpacing[1]);
+
+			if (mLogoAlignment == ALIGN_LEFT)
+				xOff = mLogoSize.x() / 10.f;
+			else if (mLogoAlignment == ALIGN_RIGHT)
+				xOff = mSize.x() - (mLogoSize.x() * 1.1f);
+			else
+				xOff = (mSize.x() - mLogoSize.x()) / 2;
+			break;
+		case HORIZONTAL_WHEEL:
+			xOff = (mSize.x() - mLogoSize.x()) / 2 - (mCamOffset * logoSpacing[1]);
+			if (mLogoAlignment == ALIGN_TOP)
+				yOff = mLogoSize.y() / 10;
+			else if (mLogoAlignment == ALIGN_BOTTOM)
+				yOff = mSize.y() - (mLogoSize.y() * 1.1f);
+			else
+				yOff = (mSize.y() - mLogoSize.y()) / 2;
+			break;
+		case HORIZONTAL:
+		default:
+			logoSpacing[0] = ((mSize.x() - (mLogoSize.x() * mMaxLogoCount)) / (mMaxLogoCount)) + mLogoSize.x();
+			xOff = (mSize.x() - mLogoSize.x()) / 2.f - (mCamOffset * logoSpacing[0]);
+
+			if (mLogoAlignment == ALIGN_TOP)
+				yOff = mLogoSize.y() / 10.f;
+			else if (mLogoAlignment == ALIGN_BOTTOM)
+				yOff = mSize.y() - (mLogoSize.y() * 1.1f);
+			else
+				yOff = (mSize.y() - mLogoSize.y()) / 2.f;
+			break;
+	}
+
+	if (mLogoPos.x() >= 0)
+		xOff = mLogoPos.x() - (mType == HORIZONTAL ? (mCamOffset * logoSpacing[0]) : 0);
+
+	if (mLogoPos.y() >= 0)
+		yOff = mLogoPos.y() - (mType == VERTICAL ? (mCamOffset * logoSpacing[1]) : 0);
+
+	int center = (int)(mCamOffset);
+	int logoCount = Math::min(mMaxLogoCount, (int)mEntries.size());
+
+	// Adding texture loading buffers depending on scrolling speed and status
+	int bufferIndex = Math::max(0, Math::min(2, getScrollingVelocity() + 1));
+	int bufferLeft = logoBuffersLeft[bufferIndex];
+	int bufferRight = logoBuffersRight[bufferIndex];
+
+	if (logoCount == 1 && mCamOffset == 0)
+	{
+		bufferLeft = 0;
+		bufferRight = 0;
+	}
+
+	auto renderLogo = [this, carouselTrans, logoSpacing, xOff, yOff](int i)
+	{
+		int index = i % (int)mEntries.size();
+		if (index < 0)
+			index += (int)mEntries.size();
+
+		Transform4x4f logoTrans = carouselTrans;
+		logoTrans.translate(Vector3f(i * logoSpacing[0] + xOff, i * logoSpacing[1] + yOff, 0));
+
+		float distance = i - mCamOffset;
+
+		float scale = 1.0f + ((mLogoScale - 1.0f) * (1.0f - fabs(distance)));
+		scale = Math::min(mLogoScale, Math::max(1.0f, scale));
+		scale /= mLogoScale;
+
+		int opacity = (int)Math::round(0x80 + ((0xFF - 0x80) * (1.0f - fabs(distance))));
+		opacity = Math::max((int)0x80, opacity);
+
+		ensureLogo(mEntries.at(index));
+
+		const std::shared_ptr<GuiComponent> &comp = mEntries.at(index).data.logo;
+		if (mType == VERTICAL_WHEEL || mType == HORIZONTAL_WHEEL) 
+		{
+			comp->setRotationDegrees(mLogoRotation * distance);
+			comp->setRotationOrigin(mLogoRotationOrigin);
+		}
+		
+		if (!comp->hasStoryBoard())
+		{
+			comp->setScale(scale);
+			comp->setOpacity((unsigned char)opacity);
+		}
+		
+		comp->render(logoTrans);
+	};
+
+
+	std::vector<int> activePositions;
+	for (int i = center - logoCount / 2 + bufferLeft; i <= center + logoCount / 2 + bufferRight; i++)
+	{
+		int index = i % (int)mEntries.size();
+		if (index < 0)
+			index += (int)mEntries.size();
+	
+		if (index == mCursor)
+			activePositions.push_back(i);
+		else
+			renderLogo(i);
+	}
+	
+	for (auto activePos : activePositions)
+		renderLogo(activePos);
+}
+
+void CarouselComponent::getCarouselFromTheme(const ThemeData::ThemeElement* elem)
+{
+	if (elem->has("type"))
+	{
+		if (!(elem->get<std::string>("type").compare("vertical")))
+			mType = VERTICAL;
+		else if (!(elem->get<std::string>("type").compare("vertical_wheel")))
+			mType = VERTICAL_WHEEL;
+		else if (!(elem->get<std::string>("type").compare("horizontal_wheel")))
+			mType = HORIZONTAL_WHEEL;
+		else
+			mType = HORIZONTAL;
+	}
+	if (elem->has("logoScale"))
+		mLogoScale = elem->get<float>("logoScale");
+	if (elem->has("logoSize"))
+		mLogoSize = elem->get<Vector2f>("logoSize") * mSize;
+	if (elem->has("logoPos"))
+		mLogoPos = elem->get<Vector2f>("logoPos") * mSize;
+	if (elem->has("maxLogoCount"))
+		mMaxLogoCount = (int)Math::round(elem->get<float>("maxLogoCount"));
+	if (elem->has("logoRotation"))
+		mLogoRotation = elem->get<float>("logoRotation");
+	if (elem->has("logoRotationOrigin"))
+		mLogoRotationOrigin = elem->get<Vector2f>("logoRotationOrigin");
+	if (elem->has("logoAlignment"))
+	{
+		if (!(elem->get<std::string>("logoAlignment").compare("left")))
+			mLogoAlignment = ALIGN_LEFT;
+		else if (!(elem->get<std::string>("logoAlignment").compare("right")))
+			mLogoAlignment = ALIGN_RIGHT;
+		else if (!(elem->get<std::string>("logoAlignment").compare("top")))
+			mLogoAlignment = ALIGN_TOP;
+		else if (!(elem->get<std::string>("logoAlignment").compare("bottom")))
+			mLogoAlignment = ALIGN_BOTTOM;
+		else
+			mLogoAlignment = ALIGN_CENTER;
+	}
+
+	if (elem->has("scrollSound"))
+		mScrollSound = elem->get<std::string>("scrollSound");
+
+	if (elem->has("defaultTransition"))
+		mDefaultTransition = elem->get<std::string>("defaultTransition");
+
+	if (elem->has("imageSource"))
+	{
+		auto direction = elem->get<std::string>("imageSource");
+		if (direction == "text")
+			mImageSource = TEXT;
+		else if (direction == "image")
+			mImageSource = IMAGE;
+		else if (direction == "marquee")
+			mImageSource = MARQUEE;
+		else
+			mImageSource = THUMBNAIL;
+	}
+	else
+		mImageSource = THUMBNAIL;
+
+}
+
+void CarouselComponent::onShow()
+{
+	GuiComponent::onShow();		
+
+	if (mCursor >= 0 && mCursor < mEntries.size())
+	{
+		auto logo = mEntries.at(mCursor).data.logo;
+		if (logo)
+		{
+			if (logo->selectStoryboard("activate"))
+				logo->startStoryboard();
+			else if (!logo->selectStoryboard())
+				logo->deselectStoryboard();
+		}
+	}
+}
+
+void CarouselComponent::onHide()
+{
+	GuiComponent::onHide();	
+}
+
+void CarouselComponent::onScreenSaverActivate()
+{
+	mScreensaverActive = true;
+}
+
+void CarouselComponent::onScreenSaverDeactivate()
+{
+	mScreensaverActive = false;
+}
+
+void CarouselComponent::topWindow(bool isTop)
+{
+	mDisable = !isTop;
+}
+
+FileData* CarouselComponent::getActiveFileData()
+{
+	if (mCursor < 0 || mCursor >= mEntries.size())
+		return nullptr;
+
+	return mEntries[mCursor].object;
+}
+
+void CarouselComponent::ensureLogo(IList<CarouselComponentData, FileData*>::Entry& entry)
+{
+	if (entry.data.logo != nullptr)
+		return;
+
+	std::string marqueePath;
+
+	if (mImageSource == IMAGE)
+		marqueePath = entry.object->getImagePath();
+	else if (mImageSource == THUMBNAIL)
+		marqueePath = entry.object->getThumbnailPath();
+	else
+		marqueePath = entry.object->getMarqueePath();
+
+	if (mImageSource != TEXT && Utils::FileSystem::exists(marqueePath))
+	{
+		ImageComponent* logo = new ImageComponent(mWindow, false, true);
+		logo->setMaxSize(mLogoSize * mLogoScale);
+		logo->setIsLinear(true);
+		logo->applyTheme(mTheme, "gamecarousel", "gamecarouselLogo", ThemeFlags::COLOR | ThemeFlags::ALIGNMENT | ThemeFlags::VISIBLE); //  ThemeFlags::PATH | 
+		logo->setImage(marqueePath, false, MaxSizeInfo(mLogoSize * mLogoScale));
+
+		entry.data.logo = std::shared_ptr<GuiComponent>(logo);
+	}
+	else // no logo in theme; use text 
+	{
+		TextComponent* text = new TextComponent(mWindow, entry.name, Renderer::isSmallScreen() ? Font::get(FONT_SIZE_MEDIUM) : Font::get(FONT_SIZE_LARGE), 0x000000FF, ALIGN_CENTER);
+		text->setScaleOrigin(0.0f);
+		text->setSize(mLogoSize * mLogoScale);
+		text->applyTheme(mTheme, "gamecarousel", "gamecarouselLogoText", ThemeFlags::FONT_PATH | ThemeFlags::FONT_SIZE | ThemeFlags::COLOR | ThemeFlags::FORCE_UPPERCASE | ThemeFlags::LINE_SPACING | ThemeFlags::TEXT);
+
+		if (mType == VERTICAL || mType == VERTICAL_WHEEL)
+		{
+			text->setHorizontalAlignment(mLogoAlignment);
+			text->setVerticalAlignment(ALIGN_CENTER);
+		}
+		else
+		{
+			text->setHorizontalAlignment(ALIGN_CENTER);
+			text->setVerticalAlignment(mLogoAlignment);
+		}
+
+		entry.data.logo = std::shared_ptr<GuiComponent>(text);
+	}
+
+	if (mType == VERTICAL || mType == VERTICAL_WHEEL)
+	{
+		if (mLogoAlignment == ALIGN_LEFT)
+			entry.data.logo->setOrigin(0, 0.5);
+		else if (mLogoAlignment == ALIGN_RIGHT)
+			entry.data.logo->setOrigin(1.0, 0.5);
+		else
+			entry.data.logo->setOrigin(0.5, 0.5);
+	}
+	else
+	{
+		if (mLogoAlignment == ALIGN_TOP)
+			entry.data.logo->setOrigin(0.5, 0);
+		else if (mLogoAlignment == ALIGN_BOTTOM)
+			entry.data.logo->setOrigin(0.5, 1);
+		else
+			entry.data.logo->setOrigin(0.5, 0.5);
+	}
+
+	Vector2f denormalized = mLogoSize * entry.data.logo->getOrigin();
+	entry.data.logo->setPosition(denormalized.x(), denormalized.y(), 0.0);
+}
+
+void CarouselComponent::add(const std::string& name, FileData* obj)
+{
+	typename IList<CarouselComponentData, FileData*>::Entry entry;
+	entry.name = name;
+	entry.object = obj;	
+	entry.data.logo = nullptr;
+
+	static_cast<IList<CarouselComponentData, FileData*>*>(this)->add(entry);
+}
+
+void CarouselComponent::applyTheme(const std::shared_ptr<ThemeData>& theme, const std::string& view, const std::string& element, unsigned int properties)
+{
+	mTheme = theme;
+
+	IList<CarouselComponentData, FileData*>::applyTheme(theme, view, element, properties);
+
+	const ThemeData::ThemeElement* carouselElem = theme->getElement(view, "gamecarousel", "gamecarousel");
+	if (carouselElem)
+		getCarouselFromTheme(carouselElem);
+}
\ No newline at end of file
diff --git a/es-app/src/components/CarouselComponent.h b/es-app/src/components/CarouselComponent.h
new file mode 100644
index 00000000..be428b60
--- /dev/null
+++ b/es-app/src/components/CarouselComponent.h
@@ -0,0 +1,101 @@
+#pragma once
+#ifndef ES_APP_VIEWS_CCCSYSTEM_VIEW_H
+#define ES_APP_VIEWS_CCCSYSTEM_VIEW_H
+
+#include "components/IList.h"
+#include "components/TextComponent.h"
+#include "resources/Font.h"
+#include "GuiComponent.h"
+#include <memory>
+#include <functional>
+
+class FileData;
+class FolderData;
+class ThemeData;
+
+struct CarouselComponentData
+{
+	std::shared_ptr<GuiComponent> logo;
+	// std::vector<GuiComponent*> backgroundExtras;
+};
+
+class CarouselComponent : public IList<CarouselComponentData, FileData*>
+{
+public:
+	CarouselComponent(Window* window);
+	~CarouselComponent();
+
+	virtual void onShow() override;
+	virtual void onHide() override;
+
+	bool input(InputConfig* config, Input input) override;
+	void update(int deltaTime) override;
+	void render(const Transform4x4f& parentTrans) override;
+
+	std::vector<HelpPrompt> getHelpPrompts() override;
+
+	void		add(const std::string& name, FileData* obj);
+	FileData*	getActiveFileData();
+
+	inline void setCursorChangedCallback(const std::function<void(CursorState state)>& func) { mCursorChangedCallback = func; }
+	void	applyTheme(const std::shared_ptr<ThemeData>& theme, const std::string& view, const std::string& element, unsigned int properties);
+
+protected:
+	void onCursorChanged(const CursorState& state) override;
+
+private:
+	void	 clearEntries();
+
+	int		 moveCursorFast(bool forward = true);
+
+	virtual void onScreenSaverActivate() override;
+	virtual void onScreenSaverDeactivate() override;
+	virtual void topWindow(bool isTop) override;
+
+	void getCarouselFromTheme(const ThemeData::ThemeElement* elem);
+
+	void renderCarousel(const Transform4x4f& parentTrans);	
+	void ensureLogo(IList<CarouselComponentData, FileData*>::Entry& entry);
+
+	// unit is list index
+	float mCamOffset;
+
+	bool mDisable;
+	bool mScreensaverActive;
+
+	std::function<void(CursorState state)> mCursorChangedCallback;
+
+	std::shared_ptr<ThemeData> mTheme;
+	int mLastCursor;	
+
+	enum ImageSource
+	{
+		TEXT,
+		THUMBNAIL,
+		IMAGE,
+		MARQUEE
+	};
+
+	enum CarouselType : unsigned int
+	{
+		HORIZONTAL = 0,
+		VERTICAL = 1,
+		VERTICAL_WHEEL = 2,
+		HORIZONTAL_WHEEL = 3
+	};
+
+	CarouselType mType;
+	ImageSource mImageSource;
+
+	float			mLogoScale;
+	float			mLogoRotation;
+	Vector2f		mLogoRotationOrigin;
+	Alignment		mLogoAlignment;
+	int				mMaxLogoCount;
+	Vector2f		mLogoSize;
+	Vector2f		mLogoPos;
+	std::string		mDefaultTransition;
+	std::string		mScrollSound;
+};
+
+#endif // ES_APP_VIEWS_SYSTEM_VIEW_H
diff --git a/es-app/src/guis/GuiMenu.cpp b/es-app/src/guis/GuiMenu.cpp
index 093f322b..8fbc1c16 100644
--- a/es-app/src/guis/GuiMenu.cpp
+++ b/es-app/src/guis/GuiMenu.cpp
@@ -2279,7 +2279,7 @@ void GuiMenu::openThemeConfiguration(Window* mWindow, GuiComponent* s, std::shar
 
 			for (auto it = mViews.cbegin(); it != mViews.cend(); ++it)
 			{
-				if (it->first == "basic" || it->first == "detailed" || it->first == "grid")
+				if (it->first == "basic" || it->first == "detailed" || it->first == "grid" || it->first == "video" || it->first == "gamecarousel")
 					styles.push_back(std::pair<std::string, std::string>(it->first, _(it->first.c_str())));
 				else
 					styles.push_back(*it);
@@ -2790,7 +2790,7 @@ void GuiMenu::openUISettings()
 				styles.push_back(std::pair<std::string, std::string>("basic", _("basic")));
 				styles.push_back(std::pair<std::string, std::string>("detailed", _("detailed")));
 				styles.push_back(std::pair<std::string, std::string>("video", _("video")));
-				styles.push_back(std::pair<std::string, std::string>("grid", _("grid")));
+				styles.push_back(std::pair<std::string, std::string>("grid", _("grid")));				
 			}
 
 			auto viewPreference = Settings::getInstance()->getString("GamelistViewStyle");
diff --git a/es-app/src/views/ViewController.cpp b/es-app/src/views/ViewController.cpp
index b9f9f3dc..1deac7f2 100644
--- a/es-app/src/views/ViewController.cpp
+++ b/es-app/src/views/ViewController.cpp
@@ -9,6 +9,7 @@
 #include "views/gamelist/IGameListView.h"
 #include "views/gamelist/GridGameListView.h"
 #include "views/gamelist/VideoGameListView.h"
+#include "views/gamelist/CarouselGameListView.h"
 #include "views/SystemView.h"
 #include "views/UIModeController.h"
 #include "FileFilterIndex.h"
@@ -543,6 +544,7 @@ std::shared_ptr<IGameListView> ViewController::getGameListView(SystemData* syste
 	//if we didn't, make it, remember it, and return it
 	std::shared_ptr<IGameListView> view;
 
+	bool themeHasGamecarouselView = system->getTheme()->hasView("gamecarousel");
 	bool themeHasVideoView = system->getTheme()->hasView("video");
 	bool themeHasGridView = system->getTheme()->hasView("grid");
 
@@ -601,6 +603,8 @@ std::shared_ptr<IGameListView> ViewController::getGameListView(SystemData* syste
 		selectedViewType = GRID;
 	else if (themeHasVideoView && viewPreference.compare("video") == 0)
 		selectedViewType = VIDEO;
+	else if (themeHasGamecarouselView && viewPreference.compare("gamecarousel") == 0)
+		selectedViewType = GAMECAROUSEL;
 
 	if (!forceView && (selectedViewType == AUTOMATIC || allowDetailedDowngrade))
 	{
@@ -639,6 +643,9 @@ std::shared_ptr<IGameListView> ViewController::getGameListView(SystemData* syste
 		case GRID:
 			view = std::shared_ptr<IGameListView>(new GridGameListView(mWindow, system->getRootFolder(), system->getTheme(), customThemeName, gridSizeOverride));
 			break;
+		case GAMECAROUSEL:
+			view = std::shared_ptr<IGameListView>(new CarouselGameListView(mWindow, system->getRootFolder()));
+			break;
 		default:
 			view = std::shared_ptr<IGameListView>(new BasicGameListView(mWindow, system->getRootFolder()));
 			break;
diff --git a/es-app/src/views/ViewController.h b/es-app/src/views/ViewController.h
index 4d4839e0..047365b3 100644
--- a/es-app/src/views/ViewController.h
+++ b/es-app/src/views/ViewController.h
@@ -72,7 +72,8 @@ class ViewController : public GuiComponent
 		BASIC,
 		DETAILED,
 		GRID,
-		VIDEO
+		VIDEO,
+		GAMECAROUSEL
 	};
 
 	struct State
diff --git a/es-app/src/views/gamelist/CarouselGameListView.cpp b/es-app/src/views/gamelist/CarouselGameListView.cpp
new file mode 100644
index 00000000..9d0fe7e1
--- /dev/null
+++ b/es-app/src/views/gamelist/CarouselGameListView.cpp
@@ -0,0 +1,289 @@
+#include "views/gamelist/CarouselGameListView.h"
+
+#include "utils/FileSystemUtil.h"
+#include "views/UIModeController.h"
+#include "views/ViewController.h"
+#include "CollectionSystemManager.h"
+#include "Settings.h"
+#include "SystemData.h"
+#include "SystemConf.h"
+#include "FileData.h"
+#include "LocaleES.h"
+
+CarouselGameListView::CarouselGameListView(Window* window, FolderData* root)
+	: ISimpleGameListView(window, root),
+	mList(window), mDetails(this, &mList, mWindow, DetailedContainer::DetailedView)
+{
+	mList.setSize(mSize.x(), mSize.y() * 0.8f);
+	mList.setPosition(0, mSize.y() * 0.2f);
+	mList.setDefaultZIndex(20);	
+	mList.setCursorChangedCallback([&](const CursorState& /*state*/) { updateInfoPanel(); });
+
+	updateInfoPanel();
+		
+	addChild(&mList);
+
+	populateList(root->getChildrenListToDisplay());
+}
+
+void CarouselGameListView::onThemeChanged(const std::shared_ptr<ThemeData>& theme)
+{
+	ISimpleGameListView::onThemeChanged(theme);
+
+	mList.applyTheme(theme, getName(), "gamecarousel", ThemeFlags::ALL);
+	mDetails.onThemeChanged(theme);
+
+	sortChildren();
+	updateInfoPanel();
+}
+
+void CarouselGameListView::updateInfoPanel()
+{
+	if (mRoot->getSystem()->isCollection())
+		updateHelpPrompts();
+
+	FileData* file = (mList.size() == 0 || mList.isScrolling()) ? NULL : mList.getSelected();
+	bool isClearing = mList.getObjects().size() == 0 && mList.getCursorIndex() == 0 && mList.getScrollingVelocity() == 0;
+	mDetails.updateControls(file, isClearing);
+}
+
+void CarouselGameListView::onFileChanged(FileData* file, FileChangeType change)
+{
+	if(change == FILE_METADATA_CHANGED)
+	{
+		// might switch to a detailed view
+		ViewController::get()->reloadGameListView(this);
+		return;
+	}
+
+	ISimpleGameListView::onFileChanged(file, change);
+}
+
+void CarouselGameListView::populateList(const std::vector<FileData*>& files)
+{
+	SystemData* system = mCursorStack.size() && mRoot->getSystem()->isGroupSystem() ? mCursorStack.top()->getSystem() : mRoot->getSystem();
+
+	auto groupTheme = system->getTheme();
+	if (groupTheme && mHeaderImage.hasImage())
+	{
+		const ThemeData::ThemeElement* logoElem = groupTheme->getElement(getName(), "logo", "image");
+		if (logoElem && logoElem->has("path") && Utils::FileSystem::exists(logoElem->get<std::string>("path")))
+			mHeaderImage.setImage(logoElem->get<std::string>("path"), false, mHeaderImage.getMaxSizeInfo());
+	}
+
+	mHeaderText.setText(system->getFullName());
+
+	mList.clear();
+
+	if (files.size() > 0)
+	{
+		bool showParentFolder = Settings::getInstance()->getBool("ShowParentFolder");
+		auto spf = Settings::getInstance()->getString(mRoot->getSystem()->getName() + ".ShowParentFolder");
+		if (spf == "1") showParentFolder = true;
+		else if (spf == "0") showParentFolder = false;
+
+		if (showParentFolder && mCursorStack.size())
+		{
+			FileData* placeholder = new FileData(PLACEHOLDER, "..", this->mRoot->getSystem());
+			mList.add(". .", placeholder);
+		}
+
+		std::string systemName = mRoot->getSystem()->getName();
+
+		bool favoritesFirst = Settings::getInstance()->getBool("FavoritesFirst");
+		
+		auto fav = Settings::getInstance()->getString(mRoot->getSystem()->getName() + ".FavoritesFirst");
+		if (fav == "1") favoritesFirst = true;
+		else if (fav == "0") favoritesFirst = false;
+		
+		bool showFavoriteIcon = (systemName != "favorites" && systemName != "recent");
+		if (!showFavoriteIcon)
+			favoritesFirst = false;
+
+		if (favoritesFirst)
+		{
+			for (auto file : files)
+			{
+				if (!file->getFavorite())
+					continue;
+				
+				if (showFavoriteIcon)
+					mList.add(_U("\uF006 ") + file->getName(), file);
+				else if (file->getType() == FOLDER)
+					mList.add(_U("\uF07C ") + file->getName(), file);
+				else
+					mList.add(file->getName(), file);
+			}
+		}
+
+		for (auto file : files)		
+		{
+			if (file->getFavorite())
+			{
+				if (favoritesFirst)
+					continue;
+
+				if (showFavoriteIcon)
+				{
+					mList.add(_U("\uF006 ") + file->getName(), file);
+					continue;
+				}
+			}
+
+			if (file->getType() == FOLDER)
+				mList.add(_U("\uF07C ") + file->getName(), file);
+			else
+				mList.add(file->getName(), file); //  + _U(" \uF05A")
+		}
+
+		// if we have the ".." PLACEHOLDER, then select the first game instead of the placeholder
+		if (showParentFolder && mCursorStack.size() && mList.size() > 1 && mList.getCursorIndex() == 0)
+			mList.setCursorIndex(1);
+	}
+	else
+	{
+		addPlaceholder();
+	}
+
+	updateFolderPath();
+
+	if (mShowing)
+		onShow();
+}
+
+FileData* CarouselGameListView::getCursor()
+{
+	if (mList.size() == 0)
+		return nullptr;
+
+	return mList.getSelected();
+}
+
+void CarouselGameListView::setCursor(FileData* cursor)
+{
+	if(!mList.setCursor(cursor) && (!cursor->isPlaceHolder()))
+	{
+		auto children = mRoot->getChildrenListToDisplay();
+
+		auto gameIter = std::find(children.cbegin(), children.cend(), cursor);
+		if (gameIter == children.cend())
+		{
+			if (cursor->getParent() != nullptr)
+				children = cursor->getParent()->getChildrenListToDisplay();
+
+			// update our cursor stack in case our cursor just got set to some folder we weren't in before
+			if (mCursorStack.empty() || mCursorStack.top() != cursor->getParent())
+			{
+				std::stack<FileData*> tmp;
+				FileData* ptr = cursor->getParent();
+				while (ptr && ptr != mRoot)
+				{
+					tmp.push(ptr);
+					ptr = ptr->getParent();
+				}
+
+				// flip the stack and put it in mCursorStack
+				mCursorStack = std::stack<FileData*>();
+				while (!tmp.empty())
+				{
+					mCursorStack.push(tmp.top());
+					tmp.pop();
+				}
+			}
+		}
+	
+		populateList(children);
+		mList.setCursor(cursor);
+	}
+}
+
+void CarouselGameListView::addPlaceholder()
+{
+	// empty list - add a placeholder
+	FileData* placeholder = new FileData(PLACEHOLDER, "<" + _("No Entries Found") + ">", mRoot->getSystem());	
+	mList.add(placeholder->getName(), placeholder);
+}
+
+std::string CarouselGameListView::getQuickSystemSelectRightButton()
+{
+	return "right";
+}
+
+std::string CarouselGameListView::getQuickSystemSelectLeftButton()
+{
+	return "left";
+}
+
+void CarouselGameListView::launch(FileData* game)
+{
+	ViewController::get()->launch(game);
+}
+
+void CarouselGameListView::remove(FileData *game)
+{
+	FolderData* parent = game->getParent();
+	if (getCursor() == game)                     // Select next element in list, or prev if none
+	{
+		std::vector<FileData*> siblings = mList.getObjects();
+
+		int gamePos = getCursorIndex();
+		if ((gamePos + 1) < (int)siblings.size())
+			setCursor(siblings.at(gamePos + 1));
+		else if ((gamePos - 1) > 0)
+			setCursor(siblings.at(gamePos - 1));
+	}
+
+	mList.remove(game);
+	if(mList.size() == 0)
+		addPlaceholder();
+
+	mRoot->removeFromVirtualFolders(game);
+	delete game;                                 // remove before repopulating (removes from parent)
+	onFileChanged(parent, FILE_REMOVED);           // update the view, with game removed
+}
+
+std::vector<HelpPrompt> CarouselGameListView::getHelpPrompts()
+{
+	std::vector<HelpPrompt> prompts;
+
+	if (mPopupSelfReference == nullptr && Settings::getInstance()->getBool("QuickSystemSelect"))
+		prompts.push_back(HelpPrompt("left/right", _("SYSTEM"))); // batocera
+
+	prompts.push_back(HelpPrompt("up/down", _("CHOOSE"))); // batocera
+	prompts.push_back(HelpPrompt(BUTTON_OK, _("LAUNCH")));
+	prompts.push_back(HelpPrompt(BUTTON_BACK, _("BACK")));
+	if(!UIModeController::getInstance()->isUIModeKid())
+	  prompts.push_back(HelpPrompt("select", _("OPTIONS"))); // batocera
+
+	FileData* cursor = getCursor();
+	if (cursor != nullptr && cursor->isNetplaySupported())
+		prompts.push_back(HelpPrompt("x", _("NETPLAY"))); // batocera
+	else
+		prompts.push_back(HelpPrompt("x", _("RANDOM"))); // batocera
+
+	if(mRoot->getSystem()->isGameSystem() && !UIModeController::getInstance()->isUIModeKid())
+	{
+		std::string prompt = CollectionSystemManager::get()->getEditingCollection();
+		
+		if (Utils::String::toLower(prompt) == "favorites")
+			prompts.push_back(HelpPrompt("y", _("Favorites")));
+		else
+			prompts.push_back(HelpPrompt("y", _(prompt.c_str())));
+	}
+	return prompts;
+}
+
+// batocera
+void CarouselGameListView::setCursorIndex(int cursor){
+	mList.setCursorIndex(cursor);
+}
+
+// batocera
+int CarouselGameListView::getCursorIndex(){
+	return mList.getCursorIndex();
+}
+
+std::vector<FileData*> CarouselGameListView::getFileDataEntries()
+{
+	return mList.getObjects();	
+}
diff --git a/es-app/src/views/gamelist/CarouselGameListView.h b/es-app/src/views/gamelist/CarouselGameListView.h
new file mode 100644
index 00000000..0b50eb86
--- /dev/null
+++ b/es-app/src/views/gamelist/CarouselGameListView.h
@@ -0,0 +1,49 @@
+#pragma once
+#ifndef ES_APP_VIEWS_GAME_LIST_CARR_GAME_LIST_VIEW_H
+#define ES_APP_VIEWS_GAME_LIST_CARR_GAME_LIST_VIEW_H
+
+#include "views/gamelist/ISimpleGameListView.h"
+#include "components/CarouselComponent.h"
+#include "DetailedContainer.h"
+
+class CarouselGameListView : public ISimpleGameListView
+{
+public:
+	CarouselGameListView(Window* window, FolderData* root);
+
+	// Called when a FileData* is added, has its metadata changed, or is removed
+	virtual void onFileChanged(FileData* file, FileChangeType change);
+
+	virtual void onThemeChanged(const std::shared_ptr<ThemeData>& theme);
+
+	virtual FileData* getCursor() override;
+	virtual void setCursor(FileData* file) override;
+	virtual int getCursorIndex() override; // batocera
+	virtual void setCursorIndex(int index) override; // batocera
+
+	virtual const char* getName() const override
+	{
+		if (!mCustomThemeName.empty())
+			return mCustomThemeName.c_str();
+
+		return "gamecarousel";
+	}
+
+	virtual std::vector<HelpPrompt> getHelpPrompts() override;
+	virtual void launch(FileData* game) override;
+	virtual std::vector<FileData*> getFileDataEntries() override;
+
+protected:
+	virtual std::string getQuickSystemSelectRightButton() override;
+	virtual std::string getQuickSystemSelectLeftButton() override;
+	virtual void populateList(const std::vector<FileData*>& files) override;
+	virtual void remove(FileData* game) override;
+	virtual void addPlaceholder();
+
+	void updateInfoPanel();
+
+	CarouselComponent mList;
+	DetailedContainer mDetails;
+};
+
+#endif // ES_APP_VIEWS_GAME_LIST_BASIC_GAME_LIST_VIEW_H
diff --git a/es-core/src/ThemeData.cpp b/es-core/src/ThemeData.cpp
index a0fc4554..bfe26fcf 100644
--- a/es-core/src/ThemeData.cpp
+++ b/es-core/src/ThemeData.cpp
@@ -14,8 +14,8 @@
 #include "LocaleES.h"
 #include "anim/ThemeStoryboard.h"
 
-std::vector<std::string> ThemeData::sSupportedViews { { "system" }, { "basic" }, { "detailed" }, { "grid" }, { "video" }, { "menu" }, { "screen" }, { "splash" } };
-std::vector<std::string> ThemeData::sSupportedFeatures { { "video" }, { "carousel" }, { "z-index" }, { "visible" },{ "manufacturer" } };
+std::vector<std::string> ThemeData::sSupportedViews{ { "system" }, { "basic" }, { "detailed" }, { "grid" }, { "video" }, { "gamecarousel" }, { "menu" }, { "screen" }, { "splash" } };
+std::vector<std::string> ThemeData::sSupportedFeatures { { "video" }, { "carousel" }, { "gamecarousel" }, { "z-index" }, { "visible" },{ "manufacturer" } };
 
 std::map<std::string, std::map<std::string, ThemeData::ElementPropertyType>> ThemeData::sElementMap {
 
@@ -384,6 +384,24 @@ std::map<std::string, std::map<std::string, ThemeData::ElementPropertyType>> The
 		{ "defaultTransition", STRING },
 		{ "scrollSound", PATH },
 		{ "zIndex", FLOAT } } },
+
+	{ "gamecarousel",{
+		{ "type", STRING },
+		{ "size", NORMALIZED_PAIR },
+		{ "pos", NORMALIZED_PAIR },
+		{ "origin", NORMALIZED_PAIR },
+		{ "imageSource", STRING }, // image, thumbnail, marquee
+		{ "logoScale", FLOAT },
+		{ "logoRotation", FLOAT },
+		{ "logoRotationOrigin", NORMALIZED_PAIR },
+		{ "logoSize", NORMALIZED_PAIR },
+		{ "logoPos", NORMALIZED_PAIR },
+		{ "logoAlignment", STRING },
+		{ "maxLogoCount", FLOAT },
+		{ "defaultTransition", STRING },
+		{ "scrollSound", PATH },
+		{ "zIndex", FLOAT } } },
+
 	{ "menuText", {
 		{ "fontPath", PATH },
 		{ "fontSize", FLOAT },
